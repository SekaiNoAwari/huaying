{"posts":[{"title":"Linux服务器常用笔记","text":"linux服务器中多个python共存【教程】linux下python2与python3共存安装教程 - 小拳头呀 - 博客园 其中可以不删除python软连接 linux命令大全Linux 命令大全 | 菜鸟教程 重装yum【Linux_Cent OS】yum错误:failure: repodata/repomd.xml from local: [Errno 256] No more mirrors to try._拾贰_C的博客-CSDN博客 linux安装包mirrors.163.com linux磁盘分析Linux磁盘分析_linux 磁盘分析_☀Mark_LY的博客-CSDN博客 常用命令 alias命令 Text1alias[别名]=[指令名称] 这个别名只有当次生效，当断开连接再次打开的时候就会失效。 如果想让别名持久化，需要把上述指令写到 ~/.bashrc 文件中，然后执行 Text1source ~/.bashrc ps -ef命令 Text1ps -ef|grep XX 查看端口占用情况 Text1netstat -anp | grep 8080 启动redis Text1./redis-server ../redis-conf 启动nacos Text1./startup.sh -m standalone 6.crontab规则 123456789- * * * * *- 分 时 日 月 周（周几）- 每5分钟定时 */5 * * * *- 每小时第3和第15分钟执行 3,5 * * * *- 每隔两天的上午8-11点的第3分钟和第15分钟执行 3,15 8-11 /2 * *","link":"/2023/05/24/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"安卓学习","text":"活动（Activity） 活动的基本用法 活动是什么 活动是最容易吸引用户的地方，他是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序可以包含零个或者多个活动，但不包含任何活动的应用程序很少。 活动的基本用法 在AndroidManifest.xml文件中注册 1234567891011&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.activitytest&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.FirstActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 由于在最外层的标签中已经通过package属性指定了程序的包名是com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity就足够了。不过仅仅像这样注册活动的程序仍然不能运行，因为还没有为程序配置主活动。配置主活动需要在标签内部加入标签，并在这个标签里添加和这两句声明即可。此外，我们还可以使用Android:label指定活动中标题栏的内容。需要注意的是，个主活动指定的label不仅会成为标题栏中的内容，还会成为启动器(Launcher)中应用程序显示的名称。 在活动中使用Toast 1Toast.makeText(FirstActivity.this,&quot;You Clicked Button 1&quot;,Toast.LENGTH_SHORT).show(); 在活动中使用menu 首先在res目录下新建一个menu文件夹，接着在这个文件夹下再新建一个名叫main的菜单（右击menu文件夹→New→Menu resouce file）在main.xml中添加如下代码： 1234567&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; android:id=&quot;@+id/remove_item&quot; android:title=&quot;Add&quot;/&gt;&lt;/menu&gt; 接着回到FirstActivity中重写onCreateOptionsMenu()方法： 1234public boolean onCreateOptionsMenu(Menu menu){ getMenuInflater().inflate(R.menu.main, menu); return true;} 通过getMenuInflater()方法能够得到MenuInflater对象，再调用它的inflate()方法就可以给当前活动创建菜单了。inflate()方法接收2个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单，这里传入R.menu.main，第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中，这里直接使用onCreateOptionsMenu()方法中传入的menu参数，然后给这个方法返回true，表示允许创建的菜单显示出来，如果返回false，创建的菜单将无法显示。 销毁一个活动 修改按钮监听器中的代码 123456button1.setOnClickListener(new View.OnClickeListener(){ @Override public void onClick(View v){ finish(); }}); 使用Intent在活动间穿梭 使用显式Intent新建SecondActivity，在AndroidManifest.xml中注册活动，修改样式修改FirstActivity中按钮的点击事件，代码如下： 1234567button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(FirstActivity.this,SecondActivity.class); startActivity(intent); }}); 使用隐式Intent 打开AndroidManifest.xml，添加如下代码： 123456&lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent_filter&gt;&lt;/activity&gt; 在标签中我们指明了当前活动可以响应com.example.activitytest.ACTION_START这个action，而标签则包含了一些附加信息，更精确地指明了当前活动能够响应的Intent中还可能带有的category。只有和中的内容能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。 修改FirstActivity中按钮的点击事件，代码如下： 1234567button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(&quot;com.example.activitytest.ACTION_START&quot;); startActivity(intent); }}); 每个Intent只能指定一个action，但却能指定多个category。需要在中添加新的category的声明。 更多隐式Intent的用法 使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android中多个程序之间的功能共享成为了可能。 修改FirstActivity中按钮点击事件的代码，如下： 12345678button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(Intent.ACTION_VIEW); Intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); startActivity(intent); }}) 与此对应，我们还可以在标签中再配置一个标签，用于更精确地指定当前活动能响应什么类型的数据。标签中主要可以配置以下内容。 1. android:scheme。用于指定数据的协议部分，如上例中的http部分。 2. android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。 3. android:port。用于指定数据的端口部分，一般紧随在主机名之后。 4. android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 5. android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。只有标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够相应该Intent。但是可以缺省除了http协议外，我们还可以指定其他很多协议，比如geo表示显示地理位置，tel表示拨打电话。下面的代码展示了如何在我们的程序中调用系统拨号界面。 12345678button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); }}) 向下一个活动传递数据在启动活动时传递数据的思路很简单，Intent中提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出就可以了。在第一个活动中12Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;extra_data&quot;, data); 在第二个活动中取出数据12Intent intent = getIntent();String data = intent.getStringExtra(&quot;extra_data&quot;); 首先可以通过getIntent()方法获取到用于启动SecondActivity的Intent，然后调用getStringExtra()方法，传入相应的简直，就可以得到传递的数据了。传入的是字符串，就用getStringExtra()，如果传递的是整型数据，则用getIntExtra()，以此类推。 返回数据给上一个活动返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动Intent来传递数据。Activity中还有一个startActivityForResult()方法也是用来启动活动的，但是这个方法期望在活动销毁的时候能返回一个结果给上一个活动。startActivityForResult()方法接收2个参数，第一个参数是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。1234567button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivityForResult(intent,i); }}); 接下来在SecondActivity中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑 1234567891011121314151617public class SecondActivity extends AppCompatActvity{ @Override protected void onCreate(Bundle savedInstanceState){ suoer.onCreate(savedInstanceState); setContentView(R.layout.second_activity); Button button2 = (Button) findViewById(R.id.button_2); button,setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;); setResult(RESULT_OK,intent); finish(); } }); }} 其中Intent只是用于传递数据，然后调用setResult()方法。这个方法是专门用于向上一个活动返回数据的。setResult()方法接收2个参数，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或者RESULT_CANCELED这两个值，第二个参数则把带有数据的Intent传递回去，然后调用finish()方法来销毁当前活动。由于我们是使用startActiityForResult()方法来启动SecondActivity的，在SecondActivity被销毁之后会调用上一个活动的onActivityResult()方法，因此我们需要在FirstActivity中重写这个方法来得到返回的数据。 1234567891011@Overrideprotected void onActivityResut(int requestCode, int resultCode, Intent data){ switch(requestCode){ case 1: if(resultCode == RESULT_OK){ String returnData = data.getStringExtra(&quot;data_return&quot;); } break; default: }} onActivityResult()方法由3个参数，第一个参数requestCode，即我们在启动活动时传入的请求码。第二个参数resultCode，即我们在返回数据时传入的处理结果。第三个参数data，即携带着返回数据的Intent。如果用户不是通过点击按钮，而是按下Back键回到FirstActivity，可以通过在SecondActivity中重写onBackPressed()方法来解决这个问题。 1234567@Overridepublic void onBackPressed(){ Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;); setResult(RESULT_OK, intent); finish();} ###活动的生命周期 返回栈 活动状态每个活动在其生命周期中最多可能会有4种状态 运行状态当一个活动位于返回栈的栈顶时，这个活动就处于运行状态。系统最不言以回收的就是处于运行状态的活动，因为这会带来非常差的用户体验 暂停状态当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。 停止状态当一个活动不再处于栈顶位置并且完全不可见是，就进入了停止状态。 销毁状态 活动的生存期Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节：·onCreate()。每个活动中都要重写这个方法，它在活动第一次被创建时调用。在这个方法中完成活动的初始化操作，比如加载布局、绑定事件等· onStart()。这个方法在活动由不可见变为课件的时候调用。· onResume()。这个方法在活动装备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。· onPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些小号CPU的资源释放掉，以及保存一些关键数据，但是这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。· onStop()。这个方法在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法不会执行。· onDestroy()。这个方法在活动被销毁之前调用，之后的活动状态将变为销毁状态。· onRestart()。这个方法在活动由停止状态变为运行状态之前调用，也就是活动呗重新启动了。以上7个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将活动氛围3种生存期。 完整生存期。活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。 可见生存期。活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在onStart()中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会过多占用内存。 前台生存期。活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到和接触得最多的也就是这个状态下的活动。 活动被回收了怎么办Activity中提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收临时数据得不到保存的问题。onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一些列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中屈指，第二个参数是真正要保存的内容。 活动的启动模式启动模式一共4个，分别为standard、singleTop、singleTask和singleInstance，可以在AndroidManifest.xml中通过给标签指定android:launchMode属性来选择启动模式。 · standard 每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。 · singleTop 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。 · singleTask 每次启动该活动时，系统会首先在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把这个活动智商的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 · singleInstance 指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动，不管哪个应用程序来访问这个活动，都公用的同一个返回栈，也就解决了共享活动实例的问题。 ###UI开发","link":"/2020/04/14/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/"},{"title":"望云归","text":"##噫吁嚱，危乎高哉，蜀道之难，难于上青天。","link":"/2020/04/14/%E6%9C%9B%E4%BA%91%E5%BD%92/"},{"title":"数据库索引相关笔记","text":"##数据库索引 数据库索引是什么 数据库的索引是存储了数据库表中某一个列的值的数据结构，最常见的是B-Tree。所以说，数据库的本质是一个数据结构。（索引是一种快速查询表中内容的机制，类似于新华字典的目录运用在表中某些字段上，但存储时，独立于表之外） 数据库索引的作用是什么 在查找次数很频繁的数据列上使用索引可以有效减少查找的时间，使数据查找更加有效率。 数据库索引的特点是什么 （查找操作花费时间比较短，删除和插入操作花费时间比较多）1.索引一旦建立，数据库管理系统会对其进行自动维护，而且由数据库管理系统决定何时使用索引2.用户不用在查询语句中指定使用哪个索引3.在定义primary key或unique约束后系统自动在相应的列上创建索引4.用户也能按照自己的需求，对指定单个字段或多个字段，添加索引 数据库索引是怎样提升性能的 在没有索引的情况下，如果查找表中数据，那么就需要一条数据一条数据地查找，比对与所查数据是否一致，极端情况下需要查到数据表最后一条，如果数据表中的数据不存在所查的数据条目的时候，甚至不能查到。因此使用索引，因为索引中只记录特定列的数据，并且通常的B-Tree是有序且分层的，查找到对应的数据的列的值会快很多。查找到特定列的值的数据之后，这条索引上会记录有该条数据所对应的表中的地址，直接读取即可获得这一条全部数据。 数据库怎么知道什么时候使用索引 当某一条查询语句（比如select * from Tabel_A where A=a ）运行的时候，数据库会检查所查询的列上是否有索引。假如该列（本例中的A）上确实有索引，数据库会接着检查这个索引做查询是否合理（因为某系情况下，使用索引会比全表扫描效率更低），当使用索引的时间预期更低的时候才会使用索引。 什么时候使用索引比不使用索引效率还低 例如，当有100万条数据，每个数据块8k，只能存10条数据，那么一共需要10万个数据块，而要查询的数据很分散，每个数据块都保存有一行。此时，全表扫描比索引扫描会快，因为此时全表扫描和索引扫描都需要10万个物理读，而索引扫描要先去索引中招到所有的rowid，然后发现还是要加载10万个数据块，结果比全表扫描多了IO。 另一个例子：一个表有100万条数据，一个数据块能保存1000条数据，那么需要1000个数据块。查询10万条数据，如果用索引扫描，那么需要从索引中找到10万行数据的rowid，然后再去执行10万次TABLE ACCESS BU ROWID，需要处理10万次数据块，虽然会缓存避免物理读，但是全表扫描只需要处理1000个数据块，显然此时全表扫描的效率会高一些。 以上只是两个比较极端的例子，用以说明并不是任何时候使用索引都会提高查询效率。 使用数据库索引有什么代价（缺点） 1.表越大，索引占用的空间越大。2.性能损失（主要是值更新操作），当你在表中添加、删除或更新行数据的时候，在索引中也会有相同的操作（建立在某列或某几列的索引需要保存该列上最新的数据） 因此，使用索引的基本原则是，如果表中某列在查询过程中使用非常频繁，那么就在该列上创建索引。 什么时候【要】创建索引 1.表经常进行select操作2.表很大（记录很多），记录内容分布范围很广3.列名经常在where子句或连接条件中出现 什么时候【不要】创建索引 1.表经常进行insert/delete/update操作2.表很小（记录很少）3.列名不经常作为连接条件或出现在where子句中 索引类型 · 唯一索引： 唯一索引不允许两行具有相同的索引值· 主键索引： 为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空· 聚集索引（Clustered）： 表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个· 非聚集索引（Non-clustered）： 非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 创建索引的语句 单个索引： 1CREATE INDEX name_index ON TABEL_A (A) 联合索引： 1CREATE INDEX name_index ON TABEL_A (A, B)","link":"/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LINUX","slug":"LINUX","link":"/tags/LINUX/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"望云归","slug":"望云归","link":"/tags/%E6%9C%9B%E4%BA%91%E5%BD%92/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"categories":[],"pages":[{"title":"飞剑","text":"toast、dialog和snackbar1. Dialog12345678910111213141516AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle(&quot;Title&quot;) .setMessage(&quot;Dialog content.&quot;) .setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }) .setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }) .show(); Dialog的作用是给用户一个提示信息，并让用户根据提示做出判断。而Dialog的特征就是，它会阻止你赝本正在进行的操作，必须停下来对Dialog进行处理。 2. ToastToast只会弹出来一段信息，告诉用户某某事情已经发生了，过一段时间后会自动消失，不会阻挡用户的任何操作。 1Toast.makeText(context, &quot;things happened&quot;, Toast.LENGTH_SHORT).show(); 但是当连续点击的时候Toast会连续触发，导致体验不佳。可以将Toast封装成一个借口，写在一个公共类当中： 1234567891011121314151617public class Util { private static Toast toast; public static void showToast(Context context, String content) { if (toast == null) { toast = Toast.makeText(context, content, Toast.LENGTH_SHORT); } else { toast.setText(content); } toast.show(); }} 调用的时候： 1Util.showToast(context, &quot;things happened&quot;); 3. Snackbar如果说Dialog和Toast是两个极端的话，那么Snackbar就是出于中间的位置了。Snackbar和Toast比较相似，但是用途更加广泛，并且他是可以和用户进行交互的。Snackbar使用一个动画效果从屏幕的底部弹出来，过一段时间后也会自动消失。在使用Snackbar之前，需要在app/build.gradle中添加相应的依赖： 123dependencies { compile 'com.android.support:design:23.4.0'} 然后就可以使用Snackbar了，他的用法和Toast是比较相似的： 1234567Snackbar.make(view, &quot;data deleted&quot;,Snackbar.LENGTH_LONG) .setAction(&quot;Undo&quot;, new View.OnClickListener(){ @Override public void onClick(View v) { } }) .show(); 这里调用Snackbar的make()方法来创建一个Snackbar对象，make()方法的第一个参数需要传入一个view，只要是当前界面布局的任意一个view都可以，Snackbar会使用这个view来自动查找最外层的布局，用于展示Snackbar。第二个参数就是Snackbar中显示的内容，第三个参数是Snackbar显示的时长。这些和Toast都是类似的。","link":"/%E9%A3%9E%E5%89%91/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}